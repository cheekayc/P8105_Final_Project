---
title: "Forecast Model"
output: github_document
---

```{r setup, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(
  message = FALSE, 
  warning = FALSE,
  fig.width = 14,
  fig.height = 6,
  out.width = "90%",
  set.seed(8))

library(tidyverse)
library(forecast)
library(astsa)
library(MLmetrics)
library(lubridate)
```

Time series forecasting involves using historical, time-stamped data to make predictions of what might happen in the future.

```{r original dataset}
# Load and clean dataset:

bakery_df = 
  read_csv("./Data/Bakery_sales.csv") %>% 
  janitor::clean_names() %>% 
  mutate(
    unit_price = str_replace(unit_price, "â‚¬", ""),
    unit_price = str_replace(unit_price, ",", "."),
    unit_price = as.numeric(unit_price),
    year = year(date),
    month = month(date),
    hour = hour(time),
    product_name = article) %>% 
  filter(product_name != ".") %>% 
  select(-article)
```

In 2021, how many products were sold each day?
```{r 2021 daily sales df}
sale_2021 = 
  bakery_df %>% 
  filter(year == 2021) %>% 
  select(date, year, month, hour, product_name, quantity, unit_price) %>% 
  group_by(date) %>% 
  summarize(
    total_sale = sum(quantity))

sale_2021
```

The `sale_2021` dataset shows the number of products sold each day in 2021. In 2021, the bakery opened for business for 339 days. 

The line plot below shows the total number of products sold each day in 2021.

```{r 2021 daily sales line plot}
sale_2021 %>% 
  ggplot(aes(x = date, y = total_sale)) +
  geom_line(aes(color = "Orange")) +
  scale_x_date(date_labels = "%b %Y", date_breaks  = "1 month") +
  labs(
    x = "Date",
    y = "Number of products sold",
    title = "Bakery's Daily Sales (2021)") +
  theme_minimal() +
  theme(legend.position = "bottom") +
  theme(plot.title = element_text(hjust = 0.4))
```

We will see this trend again as we verify the accuracy of different forecast models in the next few sections.


## Data Pre-processing

We need to create a simple and clean dataframe derived from the original dataset `bakery_df` that can be used by the forecast models. This new dataframe only needs two columns:                          
* `date` : date order in which the bakery opened for business                                                                                                                                               
* `total_sale` : sum of products sold 

The `sales_all` dataframe consists of 600 rows, in which the dates begin with *January 2, 2021* and end with *September 30, 2022*. 

```{r simplify df}
sales_all = 
  bakery_df %>% 
  group_by(date) %>% 
  summarize(
    total_sale = sum(quantity))
```

Then, we need to create a `train` and a `test` data frames so that we can test the accuracy of our forecast models. We will be using all data prior to *September 1, 2022* as our `train` dataset 
to predict the amount of products sold daily for September, 2022. The remaining data from *September 1, 2022* to *September 30, 2022* will be our `test` dataset.

```{r train test df}
train = 
  sales_all %>% 
  filter(date < "2022-09-01")

test = 
  sales_all %>% 
  filter(year(date) == 2022 & month(date) == 9)
```


### Mean Absolute Percentage Error (MAPE)

For model evaluation, we will be relying on the ***Mean Absolute Percentage Error (MAPE)*** to measure the accuracy of our predictions.

The accuracy of the model can be calculated as $100 - MAPE$. For example, an *MAPE* value of 70 indicates the model has an accuracy of 30%.


## Seasonal Naive Model

First, we begin with the most basic forecast model - the **Seasonal Naive Model**.

Naive forecasting is a simple and cost-effective method in which the forecasts produced are equal to the last observed value. The seasonal naive approach is used 
when the time series exhibits seasonality, in which case, the forecasts are equivalent to the value from the last season. Naive methods are typically used as a 
benchmark against which more sophisticated forecasting techniques can be compared. 

```{r SNM}
# Fit the model
seasonal_naive_model = snaive(train$total_sale, h = length(test$total_sale))

# Compute error of the model
SNM_error = MAPE(seasonal_naive_model$mean, test$total_sale) * 100
```

**The accuracy of the *Seasonal Naive* model is `r sum(SNM_error = 100-SNM_error)`.**

The *Seasonal Naive* model will output a list of mean values, and they are the predicted values of daily sales from September 1, 2022 to September 30, 2022.
We need to extract the list of mean values from the model and put them into the `test` dataframe so that we can produce a time-series forecast plot.

```{r SNM predict}
test_seasonal = 
  test %>% 
  mutate(
    pred_sale = seasonal_naive_model$mean)
```

Finally, we can plot a time-series forecasting graph to show the results of our *Seasonal Naive* model.

```{r plot SNM prediction}
train %>% 
  ggplot(aes(x = date, y = total_sale)) +
  geom_line(aes(color = "Actual sale (Prior to 2022-09-01)")) +
  geom_line(data = test_seasonal, aes(x = date, y = total_sale, color = "Actual sale (2022-09-01 to 2022-09-30)")) + 
  geom_line(data = test_seasonal, aes(x = date, y = pred_sale, color = "Predicted sale (2022-09-01 to 2022-09-30)"), size = 1.5) +
  scale_x_date(date_labels = "%b %Y", date_breaks  = "2 month") +
  labs(
    x = "Date",
    y = "Number of products sold",
    title = "Seasonal Naive Forecast of Daily Sales for September (2022)") +
  theme_minimal() +
  theme(legend.position = "bottom") +
  theme(plot.title = element_text(hjust = 0.4))
```

Comments: Although the *Seasonal Naive Model* gives high accuracy, the prediction line is a horizontal straight line, which means this model predicted that 
the amount of products sold is the same for each day. Therefore, we think that the predictions from this model are not the best.


## Double-Seasonal Holt-Winters (DSHW)

```{r}
double_seasonal_model = dshw(train$total_sale, period1 = 7, period2 = 14, h = length(test$total_sale))

print("The error rate of this model is")

MAPE(double_seasonal_model$mean, test$total_sale) * 100
```

```{r}
test_double_seasonal = 
  test %>% 
  mutate(
    pred_sale = double_seasonal_model$mean)
```

```{r}
train %>% 
  ggplot(aes(x = date, y = total_sale)) +
  geom_line(aes(color = "Actual sale (2021)")) +
  geom_line(data = test_double_seasonal, aes(x = date, y = total_sale, color = "Actual sale (2022)")) + 
  geom_line(data = test_double_seasonal, aes(x = date, y = pred_sale, color = "Predicted sale")) +
  labs(
    x = "Date",
    y = "Number of products sold",
    title = "Double-Seasonal Holt-Winters Forecast for January, 2022")
```

This model should be better than the basic one because it is dynamic, but still shit because error is bigger than the basic one...


## TBATS

```{r}
TBATS_model = tbats(train$total_sale)

tbats_df = forecast(TBATS_model, h = length(test$total_sale))

print("The error rate of this model is")

MAPE(tbats_df$mean, test$total_sale) * 100
```

```{r}
test_tbats = 
  test %>% 
  mutate(
    pred_sale = tbats_df$mean)
```

```{r}
train %>% 
  ggplot(aes(x = date, y = total_sale)) +
  geom_line(aes(color = "Actual sale (2021)")) +
  geom_line(data = test_tbats, aes(x = date, y = total_sale, color = "Actual sale (2022)")) + 
  geom_line(data = test_tbats, aes(x = date, y = pred_sale, color = "Predicted sale"), size = 0.8) +
  labs(
    x = "Date",
    y = "Number of products sold",
    title = "TBATS Forecast for January, 2022")
```

Our model's accuracy is getting better, but it tends to over forecast. However, over forecasting can help the bakery to meet daily demand of products...


## Neural Network

```{r}
nn_model = nnetar(train$total_sale)

nn_forecast_df = forecast(nn_model, h = length(test$total_sale))

print("The error rate of this model is")

MAPE(nn_forecast_df$mean, test$total_sale) * 100
```

```{r}
test_nn = 
  test %>% 
  mutate(
    pred_sale = nn_forecast_df$mean)
```

```{r}
train %>% 
  filter(date > "2022-01-01") %>% 
  ggplot(aes(x = date, y = total_sale)) +
  geom_line(aes(color = "Actual sale (2021)")) +
  geom_line(data = test_nn, aes(x = date, y = total_sale, color = "Actual sale (2022)"), alpha = 0.8) + 
  geom_line(data = test_nn, aes(x = date, y = pred_sale, color = "Predicted sale"), size = 0.6, alpha = 0.8) +
  scale_x_date(date_labels="%y-%m", date_breaks  = "1 month") +
  labs(
    x = "Date",
    y = "Number of products sold",
    title = "Neural Network Forecast for September, 2022") +
  theme_minimal() +
  theme(legend.position = "bottom") +
  theme(plot.title = element_text(hjust = 0.4))
```


## Sales Forecast for Oct - Dec 2022

As we have identified that the *Neural Network* model gives us the highest accuracy (), we will use this model to predict the future sales in October to December in 2022.

```{r}
train_future = 
  sales_all
```

```{r}
nn_future = nnetar(train_future$total_sale)

nn_future_df = forecast(nn_future, h = 92)

set.seed(2022)

dates = seq(as.Date('2022-10-01'), as.Date('2022-12-31'), by = 'days')

date_df =
  tibble(
    A = letters[sample(1:26, 92, TRUE)])

date_df = 
  tibble(
    date = rep(dates, length.out = nrow(date_df)))

date_df =
  date_df %>% 
  mutate(
    pred_sale = nn_future_df$mean)
```

The plot below shows the predicted daily sales of the bakery from October to December in 2022. 

```{r predicted sales}
date_df %>% 
  ggplot(aes(x = date)) +
  geom_line(aes(y = pred_sale, color = "Red")) +
  scale_x_date(date_labels="%m-%d", date_breaks  = "10 day") +
  labs(
    x = "Date (Month-Day)",
    y = "Number of products sold",
    title = "Predicted Daily Sales from October to December (2022)") +
  theme_minimal() +
  theme(legend.position = "none") +
  theme(plot.title = element_text(hjust = 0.4))
```
